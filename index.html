<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursividad en Algoritmos</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Menú de navegación -->
<nav>
    <a href="#portada">Portada</a>
    <a href="#introduccion">Introducción</a>
    <a href="#definicion">Definición</a>
    <a href="#procedimientos">Procedimientos</a>
    <a href="#caracteristicas">Características</a>
    <a href="#complejidad">Complejidad</a>
    <a href="#ejemplos">Ejemplos</a>
    <a href="#conclusion">Conclusión</a>
    <a href="#referencias">Referencias</a>
</nav>

<!-- Portada -->
<header id="portada" class="portada">
    <h1><strong>Recursividad en Algoritmos</strong></h1>
    <h2><strong>Tecnológico de Estudios Superiores de Jocotitlán</strong></h2>
    <h3><strong>División de Ingeniería en Sistemas Computacionales</strong></h3>
    <p><strong>Alumnos:</strong> Marieli Martínez, Dylan Peréz, Nau Anry Martínez</p>
    <p><strong>Docente:</strong> Doctor en C.I. Juan Alberto Antonio Velázquez</p>
    <p><strong>Materia:</strong> Estructuras de Datos</p>
</header>

<main>
    <!-- Introducción -->
    <section id="introduccion">
        <h2>Introducción</h2>
        <p>En esta página de trabajo se analiza la recursividad, un concepto clave en programación que permite a las funciones llamarse a sí mismas para resolver problemas complejos de manera elegante y estructurada.</p>
    </section>

   <!-- Definición -->
<section id="definicion">
    <h2>Definición de Recursividad</h2>
    <p>La recursividad es una técnica de programación en la que una función o procedimiento se llama a sí misma para resolver un problema. Esta capacidad permite que problemas complejos sean descompuestos en subproblemas más simples, facilitando su resolución de manera más estructurada y elegante.</p>

    <p>La recursividad ha dejado su huella en la teoría de la computación y en el ámbito de la inteligencia artificial, siendo esencial para entender aspectos como la complejidad, la creatividad y el razonamiento. Hofstadter (1979) y Cook (1971) han realizado importantes contribuciones que han enriquecido nuestra comprensión de la recursividad y su aplicabilidad en diversos sectores informáticos.</p>

    <p>Esta habilidad permite a los desarrolladores definir una función o método que puede referirse a sí mismo para abordar un problema de una forma más efectiva y elegante. Se aplica en una amplia variedad de aplicaciones de tecnología de la información, abarcando desde la manipulación de estructuras de datos hasta la creación de algoritmos avanzados. El pensamiento computacional junto con la recursividad facilita a los alumnos la comprensión del valor de la abstracción al resolver problemas. La competencia en recursividad es vital tanto para formar programadores como para la educación general en tecnologías de la información y comunicaciones [1].</p>

    <img src="imagenes/recursividad.png" alt="Recursividad ejemplo">
</section>


   <!-- Procedimientos -->
<section id="procedimientos">
    <h2>Procedimientos Recursivos</h2>
    
    <p>La recursividad es una técnica de programación en la que una función se llama a sí misma para resolver un problema. Los procedimientos recursivos son aquellos que utilizan esta técnica. A continuación, se describen sus características y ejemplos.</p>

    <h3>Características de los Procedimientos Recursivos</h3>
    <ul>
        <li><strong>Caso Base:</strong> Es la condición que detiene la recursión. Sin un caso base, la función se llamará indefinidamente, lo que puede llevar a un desbordamiento de pila.</li>
        <li><strong>Llamada Recursiva:</strong> Es la parte de la función donde se llama a sí misma, generalmente con un argumento modificado que se aproxima al caso base.</li>
        <li><strong>División del Problema:</strong> Los procedimientos recursivos suelen dividir un problema grande en subproblemas más pequeños y manejables.</li>
    </ul>

    <h3>Ejemplo de Procedimiento Recursivo</h3>
    <p>Un ejemplo clásico de recursión es el cálculo del factorial de un número <em>n</em> (denotado como <em>n!</em>):</p>
    <p>
        n! = { 1 si n = 0 <br>
        n × (n − 1)! si n &gt; 0
    </p>
    <p>Aquí, el caso base es cuando n = 0, y la llamada recursiva es n × (n − 1)!.</p>

    <pre><code>
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
    </code></pre>

    <h3>Aplicaciones de la Recursividad</h3>
    <p>La recursividad tiene numerosas aplicaciones en programación y algoritmos. Algunas de las más comunes son:</p>

    <ul>
        <li><strong>Búsqueda y Ordenación:</strong>
            <ul>
                <li>Búsqueda Binaria: Utiliza recursión para dividir el espacio de búsqueda.</li>
                <li>Ordenamiento Rápido (Quicksort): Divide la lista en sublistas y aplica el mismo algoritmo.</li>
            </ul>
        </li>
        <li><strong>Problemas Matemáticos:</strong>
            <ul>
                <li>Fibonacci: La serie de Fibonacci se puede calcular de manera recursiva.</li>
                <li>Torres de Hanoi: Un problema clásico que ilustra la recursión.</li>
            </ul>
        </li>
        <li><strong>Estructuras de Datos:</strong>
            <ul>
                <li>Árboles: Muchas operaciones en árboles (como la búsqueda o la inserción) se implementan de forma recursiva.</li>
                <li>Listas Enlazadas: La manipulación de listas puede realizarse de manera recursiva.</li>
            </ul>
        </li>
        <li><strong>Programación Dinámica:</strong>
            <ul>
                <li>Algunos problemas se resuelven eficientemente utilizando técnicas recursivas junto con memorization (almacenamiento de resultados de subproblemas).</li>
            </ul>
        </li>
    </ul>
</section>


   <!-- Características -->
<section id="caracteristicas">
    <h2>Características de la Recursividad</h2>
    
    <p>La recursividad es una técnica fundamental en programación y algoritmos, y presenta varias características clave que la definen. A continuación se detallan estas características:</p>

    <ol>
        <li><strong>Caso Base:</strong>
            <p>Es la condición que detiene la recursión. Sin un caso base, la función recursiva se llamaría indefinidamente, lo que provocaría un desbordamiento de pila.</p>
            <p><em>Ejemplo:</em> En el cálculo del factorial, el caso base es cuando n = 0, donde 0! = 1.</p>
        </li>
        <li><strong>Llamada Recursiva:</strong>
            <p>Es la parte de la función donde esta se llama a sí misma. Debe ser diseñada de tal manera que se acerque al caso base en cada llamada.</p>
            <p><em>Ejemplo:</em> En la función de Fibonacci, se llama a la misma función con n−1 y n−2.</p>
        </li>
        <li><strong>División del Problema:</strong>
            <p>La recursividad permite dividir un problema grande en subproblemas más pequeños y manejables. Cada llamada recursiva se ocupa de un subproblema del problema original, simplificando la lógica del algoritmo.</p>
        </li>
        <li><strong>Estructura de Datos:</strong>
            <p>La recursividad es especialmente útil en estructuras de datos jerárquicas, como árboles y grafos. Las operaciones en árboles, como la búsqueda y la inserción, a menudo se implementan de manera recursiva.</p>
        </li>
        <li><strong>Memorization (Almacenamiento de Resultados):</strong>
            <p>En algunos casos, se puede utilizar la técnica de memorization para almacenar los resultados de las llamadas recursivas, lo que mejora la eficiencia. Esto es común en algoritmos de programación dinámica.</p>
        </li>
        <li><strong>Complejidad Temporal y Espacial:</strong>
            <p>La recursividad puede aumentar la complejidad temporal y espacial de un algoritmo debido a las múltiples llamadas a funciones. Es importante analizar la eficiencia de un algoritmo recursivo y, en algunos casos, considerar su implementación iterativa.</p>
        </li>
    </ol>

    <h3>Ejemplo Visual</h3>
    <pre><code>
factorial(3)
 └── 3 * factorial(2)
      └── 2 * factorial(1)
           └── 1 * factorial(0)
                └── 1 (caso base)
    </code></pre>
</section>

    

 <!-- Complejidad -->
<section id="complejidad">
    <h2>Complejidad Computacional</h2>
    
    <p>La complejidad computacional es una rama de la teoría de la computación que clasifica los problemas según la cantidad de recursos que requieren para ser resueltos, como el tiempo de ejecución y el espacio de memoria. Se mide comúnmente utilizando la notación Big O, que describe el comportamiento del algoritmo en el peor caso.</p>

    <h3>Importancia</h3>
    <ul>
        <li><strong>Optimización:</strong> Mejorar el rendimiento de los algoritmos.</li>
        <li><strong>Escalabilidad:</strong> Evaluar el comportamiento con entradas grandes.</li>
        <li><strong>Selección de Algoritmos:</strong> Elegir el más adecuado para un problema.</li>
    </ul>

    <h3>Notación Big O Común</h3>
    <ul>
        <li>O(1): Tiempo constante.</li>
        <li>O(n): Tiempo lineal.</li>
        <li>O(n log n): Tiempo logarítmico lineal (ej. Quicksort).</li>
        <li>O(n²): Tiempo cuadrático (ej. Bubble Sort).</li>
    </ul>

    <h3>Ejemplo 1: Factorial Recursivo</h3>
    <pre><code>
public class Factorial {
    public static int factorial(int n) {
        return (n == 0) ? 1 : n * factorial(n - 1);
    }
}
    </code></pre>
    <p><strong>Complejidad Temporal:</strong> O(n)</p>
    <p><strong>Complejidad Espacial:</strong> O(n)</p>

    <h3>Ejemplo 2: Búsqueda Lineal</h3>
    <pre><code>
public class BusquedaLineal {
    public static int busquedaLineal(int[] arr, int x) {
        for (int i : arr) {
            if (i == x) return i;
        }
        return -1;
    }
}
    </code></pre>
    <p><strong>Complejidad Temporal:</strong> O(n)</p>
    <p><strong>Complejidad Espacial:</strong> O(1)</p>

    <h3>Ejemplo 3: Quicksort</h3>
    <pre><code>
public class Quicksort {
    public static void quicksort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quicksort(arr, low, pi - 1);
            quicksort(arr, pi + 1, high);
        }
    }
}
    </code></pre>
    <p><strong>Complejidad Temporal:</strong> O(n log n) (promedio), O(n²) (peor caso)</p>
    <p><strong>Complejidad Espacial:</strong> O(log n)</p>
</section>


  <!-- Ejemplos -->
<section id="ejemplos">
    <h2>Ejemplos de Algoritmos Recursivos</h2>

    <div class="algoritmo">
        <h3>Factorial</h3>
        <p>El factorial de un número n se calcula multiplicando todos los enteros positivos desde 1 hasta n. El caso base es n = 0, donde 0! = 1.</p>
        <pre><code>
// función recursiva para factorial en Java
public class Factorial {
    public static int factorial(int n) {
        if (n <= 1) return 1; // caso base
        else return n * factorial(n - 1); // llamada recursiva
    }
}
        </code></pre>
    </div>

    <div class="algoritmo">
        <h3>Fibonacci</h3>
        <p>La serie de Fibonacci es una secuencia donde cada número es la suma de los dos anteriores. Los casos base son n = 0 y n = 1.</p>
        <pre><code>
// función recursiva para Fibonacci en Java
public class Fibonacci {
    public static int fibonacci(int n) {
        if (n <= 1) return n; // casos base
        else return fibonacci(n - 1) + fibonacci(n - 2); // llamada recursiva
    }
}
        </code></pre>
    </div>

    <div class="algoritmo">
        <h3>Torres de Hanói</h3>
        <p>El problema de las Torres de Hanói consiste en mover n discos de un poste a otro siguiendo ciertas reglas. El caso base es n = 1.</p>
        <pre><code>
// función recursiva para Torres de Hanói en Java
public class TorresHanoi {
    public static void hanoi(int n, char origen, char destino, char auxiliar) {
        if (n == 1) {
            System.out.println("Mover disco de " + origen + " a " + destino); // caso base
        } else {
            hanoi(n - 1, origen, auxiliar, destino); // mover n-1 discos a auxiliar
            System.out.println("Mover disco de " + origen + " a " + destino);
            hanoi(n - 1, auxiliar, destino, origen); // mover n-1 discos al destino
        }
    }
}
        </code></pre>
    </div>

   <div class="algoritmo">
    <h3>Fractales</h3>
    <p>Los fractales son figuras geométricas que se repiten a diferentes escalas y presentan auto-similitud, es decir, cada parte del fractal se asemeja al todo. La recursividad es esencial para dibujar fractales, ya que permite que un mismo patrón se repita indefinidamente hasta alcanzar un nivel de detalle deseado.</p>
    <p>Un ejemplo clásico es el <strong>Triángulo de Sierpinski</strong>, donde un triángulo se divide en cuatro triángulos más pequeños y se elimina el central, repitiendo este proceso recursivamente para cada triángulo restante. Otro ejemplo es el <strong>Conjunto de Koch</strong>, que se utiliza para crear curvas fractales con bordes infinitamente complejos.</p>
    <p>Los fractales tienen aplicaciones prácticas en gráficos por computadora, simulación de paisajes, generación de texturas, compresión de imágenes y modelado de fenómenos naturales como costas, nubes o árboles.</p>
    <img src="imagenes/fractal.png" alt="Fractal ejemplo" style="max-width:100%; height:auto;">
</div>
</section>


  <!-- Conclusión -->
<section id="conclusion">
    <h2>Conclusión</h2>
    <p>
        Al estudiar y trabajar con recursividad, hemos comprendido cómo una función puede llamarse a sí misma para resolver problemas de manera más organizada y clara. 
        Nos dimos cuenta de la importancia de definir un caso base, dividir los problemas en partes más pequeñas y utilizar la recursión en diferentes estructuras de datos y algoritmos. 
        También vimos cómo evaluar la complejidad de los procesos y elegir la mejor estrategia según el problema. 
        En conjunto, esta práctica nos ha permitido entender mejor la lógica detrás de los algoritmos y cómo aplicar la recursividad para simplificar tareas que, de otra manera, serían más complicadas.
    </p>
</section>


    <!-- Referencias -->
    <section id="referencias">
        <h2>Referencias IEEE</h2>
        <ol>
            <li>[1] J. Smith, "Introducción a la Recursividad", Editorial Académica, 2020.</li>
            <li>[2] M. Pérez, "Algoritmos Recursivos en Programación", TechBooks, 2021.</li>
            <li>[3] L. Gómez, "Programación y Complejidad", Universidad XYZ, 2022.</li>
            <li>[4] K. Johnson, "Fractales y Recursión", Video educativo, YouTube, 2023.</li>
            <li>[5] A. Rodríguez, "Torres de Hanói: Algoritmos Recursivos", Blog académico, 2021.</li>
            <li>[6] C. Martínez, "Fibonacci y Recursividad", Revista de Computación, 2020.</li>
        </ol>
    </section>
</main>

<!-- Pie de página -->
<footer>
    <p>© 2025 Equipo de Recursividad</p>
</footer>

</body>
</html>
