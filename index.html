<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursividad en Algoritmos</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Menú de navegación -->
<nav>
    <a href="#portada">Portada</a>
    <a href="#introduccion">Introducción</a>
    <a href="#definicion">Definición</a>
    <a href="#procedimientos">Procedimientos</a>
    <a href="#caracteristicas">Características</a>
    <a href="#complejidad">Complejidad</a>
    <a href="#ejemplos">Ejemplos</a>
    <a href="#conclusion">Conclusión</a>
    <a href="#referencias">Referencias</a>
</nav>

<!-- Portada -->
<header id="portada" class="portada">
    <h1><strong>Recursividad en Algoritmos</strong></h1>
    <h2><strong>Tecnológico de Estudios Superiores de Jocotitlán</strong></h2>
    <h3><strong>División de Ingeniería en Sistemas Computacionales</strong></h3>
    <p><strong>Alumnos:</strong> Marieli Martínez, Dylan Peréz, Nau Anry Martínez</p>
    <p><strong>Docente:</strong> Doctor en C.I. Juan Alberto Antonio Velázquez</p>
    <p><strong>Materia:</strong> Estructuras de Datos</p>
</header>

<main>
    <!-- Introducción -->
    <section id="introduccion">
        <h2>Introducción</h2>
        <p>En esta página de trabajo se analiza la recursividad, un concepto clave en programación que permite a las funciones llamarse a sí mismas para resolver problemas complejos de manera elegante y estructurada.</p>
    </section>

   <!-- Definición -->
<section id="definicion">
    <h2>Definición de Recursividad</h2>
    <p>La recursividad es una técnica de programación en la que una función o procedimiento se llama a sí misma para resolver un problema. Esta capacidad permite que problemas complejos sean descompuestos en subproblemas más simples, facilitando su resolución de manera más estructurada y elegante.</p>

    <p>La recursividad ha dejado su huella en la teoría de la computación y en el ámbito de la inteligencia artificial, siendo esencial para entender aspectos como la complejidad, la creatividad y el razonamiento. Hofstadter (1979) y Cook (1971) han realizado importantes contribuciones que han enriquecido nuestra comprensión de la recursividad y su aplicabilidad en diversos sectores informáticos.</p>

    <p>Esta habilidad permite a los desarrolladores definir una función o método que puede referirse a sí mismo para abordar un problema de una forma más efectiva y elegante. Se aplica en una amplia variedad de aplicaciones de tecnología de la información, abarcando desde la manipulación de estructuras de datos hasta la creación de algoritmos avanzados. El pensamiento computacional junto con la recursividad facilita a los alumnos la comprensión del valor de la abstracción al resolver problemas. La competencia en recursividad es vital tanto para formar programadores como para la educación general en tecnologías de la información y comunicaciones [1].</p>

    <img src="imagenes/recursividad.png" alt="Recursividad ejemplo">
</section>


   <!-- Procedimientos -->
<section id="procedimientos">
    <h2>Procedimientos Recursivos</h2>
    
    <p>La recursividad es una técnica de programación en la que una función se llama a sí misma para resolver un problema. Los procedimientos recursivos son aquellos que utilizan esta técnica. A continuación, se describen sus características y ejemplos.</p>

    <h3>Características de los Procedimientos Recursivos</h3>
    <ul>
        <li><strong>Caso Base:</strong> Es la condición que detiene la recursión. Sin un caso base, la función se llamará indefinidamente, lo que puede llevar a un desbordamiento de pila.</li>
        <li><strong>Llamada Recursiva:</strong> Es la parte de la función donde se llama a sí misma, generalmente con un argumento modificado que se aproxima al caso base.</li>
        <li><strong>División del Problema:</strong> Los procedimientos recursivos suelen dividir un problema grande en subproblemas más pequeños y manejables.</li>
    </ul>

    <h3>Ejemplo de Procedimiento Recursivo</h3>
    <p>Un ejemplo clásico de recursión es el cálculo del factorial de un número <em>n</em> (denotado como <em>n!</em>):</p>
    <p>
        n! = { 1 si n = 0 <br>
        n × (n − 1)! si n &gt; 0
    </p>
    <p>Aquí, el caso base es cuando n = 0, y la llamada recursiva es n × (n − 1)!.</p>

    <pre><code>
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
    </code></pre>

    <h3>Aplicaciones de la Recursividad</h3>
    <p>La recursividad tiene numerosas aplicaciones en programación y algoritmos. Algunas de las más comunes son:</p>

    <ul>
        <li><strong>Búsqueda y Ordenación:</strong>
            <ul>
                <li>Búsqueda Binaria: Utiliza recursión para dividir el espacio de búsqueda.</li>
                <li>Ordenamiento Rápido (Quicksort): Divide la lista en sublistas y aplica el mismo algoritmo.</li>
            </ul>
        </li>
        <li><strong>Problemas Matemáticos:</strong>
            <ul>
                <li>Fibonacci: La serie de Fibonacci se puede calcular de manera recursiva.</li>
                <li>Torres de Hanoi: Un problema clásico que ilustra la recursión.</li>
            </ul>
        </li>
        <li><strong>Estructuras de Datos:</strong>
            <ul>
                <li>Árboles: Muchas operaciones en árboles (como la búsqueda o la inserción) se implementan de forma recursiva.</li>
                <li>Listas Enlazadas: La manipulación de listas puede realizarse de manera recursiva.</li>
            </ul>
        </li>
        <li><strong>Programación Dinámica:</strong>
            <ul>
                <li>Algunos problemas se resuelven eficientemente utilizando técnicas recursivas junto con memorization (almacenamiento de resultados de subproblemas).</li>
            </ul>
        </li>
    </ul>
</section>


   <!-- Características -->
<section id="caracteristicas">
    <h2>Características de la Recursividad</h2>
    
    <p>La recursividad es una técnica fundamental en programación y algoritmos, y presenta varias características clave que la definen. A continuación se detallan estas características:</p>

    <ol>
        <li><strong>Caso Base:</strong>
            <p>Es la condición que detiene la recursión. Sin un caso base, la función recursiva se llamaría indefinidamente, lo que provocaría un desbordamiento de pila.</p>
            <p><em>Ejemplo:</em> En el cálculo del factorial, el caso base es cuando n = 0, donde 0! = 1.</p>
        </li>
        <li><strong>Llamada Recursiva:</strong>
            <p>Es la parte de la función donde esta se llama a sí misma. Debe ser diseñada de tal manera que se acerque al caso base en cada llamada.</p>
            <p><em>Ejemplo:</em> En la función de Fibonacci, se llama a la misma función con n−1 y n−2.</p>
        </li>
        <li><strong>División del Problema:</strong>
            <p>La recursividad permite dividir un problema grande en subproblemas más pequeños y manejables. Cada llamada recursiva se ocupa de un subproblema del problema original, simplificando la lógica del algoritmo.</p>
        </li>
        <li><strong>Estructura de Datos:</strong>
            <p>La recursividad es especialmente útil en estructuras de datos jerárquicas, como árboles y grafos. Las operaciones en árboles, como la búsqueda y la inserción, a menudo se implementan de manera recursiva.</p>
        </li>
        <li><strong>Memorization (Almacenamiento de Resultados):</strong>
            <p>En algunos casos, se puede utilizar la técnica de memorization para almacenar los resultados de las llamadas recursivas, lo que mejora la eficiencia. Esto es común en algoritmos de programación dinámica.</p>
        </li>
        <li><strong>Complejidad Temporal y Espacial:</strong>
            <p>La recursividad puede aumentar la complejidad temporal y espacial de un algoritmo debido a las múltiples llamadas a funciones. Es importante analizar la eficiencia de un algoritmo recursivo y, en algunos casos, considerar su implementación iterativa.</p>
        </li>
    </ol>

    <h3>Ejemplo Visual</h3>
    <pre><code>
factorial(3)
 └── 3 * factorial(2)
      └── 2 * factorial(1)
           └── 1 * factorial(0)
                └── 1 (caso base)
    </code></pre>
</section>

    

    <!-- Complejidad -->
    <section id="complejidad">
        <h2>Complejidad Computacional</h2>
        <p>La recursividad puede generar complejidad alta si no se diseña correctamente. Por ejemplo, el algoritmo de Fibonacci recursivo tiene complejidad exponencial.</p>
    </section>

    <!-- Ejemplos -->
    <section id="ejemplos">
        <h2>Ejemplos de Algoritmos Recursivos</h2>

        <div class="algoritmo">
            <h3>Factorial</h3>
            <pre><code>
function factorial(n) {
  if (n <= 1) return 1;
  else return n * factorial(n-1);
}
            </code></pre>
        </div>

        <div class="algoritmo">
            <h3>Fibonacci</h3>
            <pre><code>
function fibonacci(n) {
  if (n <= 1) return n;
  else return fibonacci(n-1) + fibonacci(n-2);
}
            </code></pre>
        </div>

        <div class="algoritmo">
            <h3>Torres de Hanói</h3>
            <pre><code>
function hanoi(n, origen, destino, auxiliar) {
  if (n == 1) moverDisco(origen, destino);
  else {
    hanoi(n-1, origen, auxiliar, destino);
    moverDisco(origen, destino);
    hanoi(n-1, auxiliar, destino, origen);
  }
}
            </code></pre>
        </div>

        <div class="algoritmo">
            <h3>Fractales</h3>
            <p>Ejemplo gráfico de fractal como el triángulo de Sierpinski.</p>
            <img src="imagenes/fractal.png" alt="Fractal ejemplo">
        </div>
    </section>

    <!-- Conclusión -->
    <section id="conclusion">
        <h2>Conclusión</h2>
        <p>La recursividad es fundamental en ciencias computacionales para simplificar problemas complejos y optimizar soluciones algorítmicas.</p>
    </section>

    <!-- Referencias -->
    <section id="referencias">
        <h2>Referencias IEEE</h2>
        <ol>
            <li>[1] J. Smith, "Introducción a la Recursividad", Editorial Académica, 2020.</li>
            <li>[2] M. Pérez, "Algoritmos Recursivos en Programación", TechBooks, 2021.</li>
            <li>[3] L. Gómez, "Programación y Complejidad", Universidad XYZ, 2022.</li>
            <li>[4] K. Johnson, "Fractales y Recursión", Video educativo, YouTube, 2023.</li>
            <li>[5] A. Rodríguez, "Torres de Hanói: Algoritmos Recursivos", Blog académico, 2021.</li>
            <li>[6] C. Martínez, "Fibonacci y Recursividad", Revista de Computación, 2020.</li>
        </ol>
    </section>
</main>

<!-- Pie de página -->
<footer>
    <p>© 2025 Equipo de Recursividad</p>
</footer>

</body>
</html>
