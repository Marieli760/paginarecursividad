<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursividad en Algoritmos</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <!-- Menú de navegación -->
    <nav>
        <a href="#portada">Portada</a>
        <a href="#introduccion">Introducción</a>
        <a href="#definicion">Definición</a>
        <a href="#procedimientos">Procedimientos</a>
        <a href="#caracteristicas">Características</a>
        <a href="#complejidad">Complejidad</a>
        <a href="#ejemplos">Ejemplos</a>
        <a href="#conclusion">Conclusión</a>
        <a href="#referencias">Referencias</a>
    </nav>

    <!-- Portada -->
<header id="portada" class="portada">
    <h1 class="titulo-principal">Recursividad en Algoritmos</h1>
    <h2 class="institucion">Tecnológico de Estudios Superiores de Jocotitlán</h2>
    <h3 class="division">División de Ingeniería en Sistemas Computacionales</h3>
    
    <div class="info-equipo">
        <p><strong>Alumnos:</strong> Marieli Martínez, Dylan Pérez, Nau Anry Martínez</p>
        <p><strong>Docente:</strong> Doctor en C.I. Juan Alberto Antonio Velázquez</p>
        <p><strong>Materia:</strong> Estructuras de Datos</p>
    </div>
</header>


    <main>
        <!-- Introducción -->
        <section id="introduccion">
            <h2>Introducción</h2>
            <p>
                En esta página de trabajo se analiza la recursividad, un concepto clave en programación que permite a las funciones llamarse a sí mismas para resolver problemas complejos de manera elegante y estructurada.
            </p>
        </section>

      <!-- Definición -->
<section id="definicion">
    <h2>Definición de Recursividad</h2>
    <p>
        La recursividad es una técnica de programación donde una función se llama a sí misma para resolver un problema. Esto permite dividir problemas complejos en partes más pequeñas y manejables, facilitando su solución.
    </p>
    <p>
        Es fundamental en computación y programación, ya que ayuda a entender la complejidad de los algoritmos y a desarrollar soluciones más organizadas y eficientes. Se aplica en estructuras de datos, algoritmos matemáticos y muchos otros ámbitos de la tecnología.
    </p>
    <img src="imagenes/recursividad.png" alt="Recursividad ejemplo">
</section>

        <!-- Procedimientos -->
        <section id="procedimientos">
            <h2>Procedimientos Recursivos</h2>
            <p>
                La recursividad es una técnica de programación en la que una función se llama a sí misma para resolver un problema. Los procedimientos recursivos son aquellos que utilizan esta técnica. A continuación, se describen sus características y ejemplos.
            </p>

            <h3>Características de los Procedimientos Recursivos</h3>
            <ul>
                <li><strong>Caso Base:</strong> Es la condición que detiene la recursión. Sin un caso base, la función se llamará indefinidamente, lo que puede llevar a un desbordamiento de pila.</li>
                <li><strong>Llamada Recursiva:</strong> Es la parte de la función donde se llama a sí misma, generalmente con un argumento modificado que se aproxima al caso base.</li>
                <li><strong>División del Problema:</strong> Los procedimientos recursivos suelen dividir un problema grande en subproblemas más pequeños y manejables.</li>
            </ul>

            <h3>Ejemplo de Procedimiento Recursivo</h3>
            <p>
                Un ejemplo clásico de recursión es el cálculo del factorial de un número <em>n</em> (denotado como <em>n!</em>):
            </p>
            <p>
                n! = { 1 si n = 0 <br> n × (n − 1)! si n &gt; 0
            </p>
            <p>
                Aquí, el caso base es cuando n = 0, y la llamada recursiva es n × (n − 1)!.
            </p>
            <pre><code>
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
            </code></pre>

            <h3>Aplicaciones de la Recursividad</h3>
            <p>La recursividad tiene numerosas aplicaciones en programación y algoritmos. Algunas de las más comunes son:</p>
            <ul>
                <li><strong>Búsqueda y Ordenación:</strong>
                    <ul>
                        <li>Búsqueda Binaria: Utiliza recursión para dividir el espacio de búsqueda.</li>
                        <li>Ordenamiento Rápido (Quicksort): Divide la lista en sublistas y aplica el mismo algoritmo.</li>
                    </ul>
                </li>
                <li><strong>Problemas Matemáticos:</strong>
                    <ul>
                        <li>Fibonacci: La serie de Fibonacci se puede calcular de manera recursiva.</li>
                        <li>Torres de Hanoi: Un problema clásico que ilustra la recursión.</li>
                    </ul>
                </li>
                <li><strong>Estructuras de Datos:</strong>
                    <ul>
                        <li>Árboles: Muchas operaciones en árboles (como la búsqueda o la inserción) se implementan de forma recursiva.</li>
                        <li>Listas Enlazadas: La manipulación de listas puede realizarse de manera recursiva.</li>
                    </ul>
                </li>
                <li><strong>Programación Dinámica:</strong>
                    <ul>
                        <li>Algunos problemas se resuelven eficientemente utilizando técnicas recursivas junto con memorization (almacenamiento de resultados de subproblemas).</li>
                    </ul>
                </li>
            </ul>
        </section>

        <!-- Características -->
        <section id="caracteristicas">
            <h2>Características de la Recursividad</h2>
            <p>La recursividad es una técnica fundamental en programación y algoritmos, y presenta varias características clave que la definen. A continuación se detallan estas características:</p>
            <ol>
                <li>
                    <strong>Caso Base:</strong>
                    <p>Es la condición que detiene la recursión. Sin un caso base, la función recursiva se llamaría indefinidamente, lo que provocaría un desbordamiento de pila.</p>
                    <p><em>Ejemplo:</em> En el cálculo del factorial, el caso base es cuando n = 0, donde 0! = 1.</p>
                </li>
                <li>
                    <strong>Llamada Recursiva:</strong>
                    <p>Es la parte de la función donde esta se llama a sí misma. Debe ser diseñada de tal manera que se acerque al caso base en cada llamada.</p>
                    <p><em>Ejemplo:</em> En la función de Fibonacci, se llama a la misma función con n−1 y n−2.</p>
                </li>
                <li>
                    <strong>División del Problema:</strong>
                    <p>La recursividad permite dividir un problema grande en subproblemas más pequeños y manejables. Cada llamada recursiva se ocupa de un subproblema del problema original, simplificando la lógica del algoritmo.</p>
                </li>
                <li>
                    <strong>Estructura de Datos:</strong>
                    <p>La recursividad es especialmente útil en estructuras de datos jerárquicas, como árboles y grafos. Las operaciones en árboles, como la búsqueda y la inserción, a menudo se implementan de manera recursiva.</p>
                </li>
                <li>
                    <strong>Memorization (Almacenamiento de Resultados):</strong>
                    <p>En algunos casos, se puede utilizar la técnica de memorization para almacenar los resultados de las llamadas recursivas, lo que mejora la eficiencia. Esto es común en algoritmos de programación dinámica.</p>
                </li>
                <li>
                    <strong>Complejidad Temporal y Espacial:</strong>
                    <p>La recursividad puede aumentar la complejidad temporal y espacial de un algoritmo debido a las múltiples llamadas a funciones. Es importante analizar la eficiencia de un algoritmo recursivo y, en algunos casos, considerar su implementación iterativa.</p>
                </li>
            </ol>

            <h3>Ejemplo Visual</h3>
            <pre><code>
factorial(3)
└── 3 * factorial(2)
    └── 2 * factorial(1)
        └── 1 * factorial(0)
            └── 1 (caso base)
            </code></pre>
        </section>

        <!-- Complejidad -->
        <section id="complejidad">
            <h2>Complejidad Computacional</h2>
            <p>
                La complejidad computacional es una rama de la teoría de la computación que clasifica los problemas según la cantidad de recursos que requieren para ser resueltos, como el tiempo de ejecución y el espacio de memoria. Se mide comúnmente utilizando la notación Big O, que describe el comportamiento del algoritmo en el peor caso.
            </p>

            <h3>Importancia</h3>
            <ul>
                <li><strong>Optimización:</strong> Mejorar el rendimiento de los algoritmos.</li>
                <li><strong>Escalabilidad:</strong> Evaluar el comportamiento con entradas grandes.</li>
                <li><strong>Selección de Algoritmos:</strong> Elegir el más adecuado para un problema.</li>
            </ul>

            <h3>Notación Big O Común</h3>
            <ul>
                <li>O(1): Tiempo constante.</li>
                <li>O(n): Tiempo lineal.</li>
                <li>O(n log n): Tiempo logarítmico lineal (ej. Quicksort).</li>
                <li>O(n²): Tiempo cuadrático (ej. Bubble Sort).</li>
            </ul>

            <h3>Ejemplos</h3>
            <div class="algoritmo">
                <h4>Factorial Recursivo</h4>
                <pre><code>
public class Factorial {
    public static int factorial(int n) {
        return (n == 0) ? 1 : n * factorial(n - 1);
    }
}
                </code></pre>
                <p><strong>Complejidad Temporal:</strong> O(n)</p>
                <p><strong>Complejidad Espacial:</strong> O(n)</p>
            </div>

            <div class="algoritmo">
                <h4>Búsqueda Lineal</h4>
                <pre><code>
public class BusquedaLineal {
    public static int busquedaLineal(int[] arr, int x) {
        for (int i : arr) {
            if (i == x) return i;
        }
        return -1;
    }
}
                </code></pre>
                <p><strong>Complejidad Temporal:</strong> O(n)</p>
                <p><strong>Complejidad Espacial:</strong> O(1)</p>
            </div>

            <div class="algoritmo">
                <h4>Quicksort</h4>
                <pre><code>
public class Quicksort {
    public static void quicksort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quicksort(arr, low, pi - 1);
            quicksort(arr, pi + 1, high);
        }
    }
}
                </code></pre>
                <p><strong>Complejidad Temporal:</strong> O(n log n) (promedio), O(n²) (peor caso)</p>
                <p><strong>Complejidad Espacial:</strong> O(log n)</p>
            </div>
        </section>

 <!-- Ejemplos -->
<section id="ejemplos">
    <h2>Ejemplos de Algoritmos Recursivos</h2>

    <div class="algoritmo">
        <h3>Factorial</h3>
        <p>
            El factorial de un número n se calcula multiplicando todos los enteros positivos desde 1 hasta n. El caso base es n = 0, donde 0! = 1.
        </p>
        <!-- Imagen ilustrativa del factorial -->
        <img src="imagenes/factorial.png" alt="Diagrama Factorial" style="max-width:100%; height:auto; margin-bottom: 10px;">
        <pre><code>
// función recursiva para factorial en Java
public class Factorial {
    public static int factorial(int n) {
        if (n <= 1) return 1; // caso base
        else return n * factorial(n - 1); // llamada recursiva
    }
}
        </code></pre>
    </div>

    <div class="algoritmo">
        <h3>Fibonacci</h3>
        <p>
            La serie de Fibonacci es una secuencia donde cada número es la suma de los dos anteriores. Los casos base son n = 0 y n = 1.
        </p>
        <!-- Imagen ilustrativa de Fibonacci -->
        <img src="imagenes/fibonacci.png" alt="Diagrama Fibonacci" style="max-width:100%; height:auto; margin-bottom: 10px;">
        <pre><code>
// función recursiva para Fibonacci en Java
public class Fibonacci {
    public static int fibonacci(int n) {
        if (n <= 1) return n; // casos base
        else return fibonacci(n - 1) + fibonacci(n - 2); // llamada recursiva
    }
}
        </code></pre>
    </div>

    <div class="algoritmo">
        <h3>Torres de Hanói</h3>
        <p>
            El problema de las Torres de Hanói consiste en mover n discos de un poste a otro siguiendo ciertas reglas. El caso base es n = 1.
        </p>
        <!-- Imagen ilustrativa de Torres de Hanói -->
        <img src="imagenes/torres_hanoi.png" alt="Diagrama Torres de Hanói" style="max-width:100%; height:auto; margin-bottom: 10px;">
        <pre><code>
// función recursiva para Torres de Hanói en Java
public class TorresHanoi {
    public static void hanoi(int n, char origen, char destino, char auxiliar) {
        if (n == 1) {
            System.out.println("Mover disco de " + origen + " a " + destino); // caso base
        } else {
            hanoi(n - 1, origen, auxiliar, destino); // mover n-1 discos a auxiliar
            System.out.println("Mover disco de " + origen + " a " + destino);
            hanoi(n - 1, auxiliar, destino, origen); // mover n-1 discos al destino
        }
    }
}
                </code></pre>
            </div>

            <div class="algoritmo">
                <h3>Fractales</h3>
                <p>
                    Los fractales son figuras geométricas que se repiten a diferentes escalas y presentan auto-similitud. La recursividad es esencial para dibujar fractales.
                </p>
                <p>
                    Ejemplos: <strong>Triángulo de Sierpinski</strong> y <strong>Conjunto de Koch</strong>. Se utilizan en gráficos, simulación, generación de texturas y modelado de fenómenos naturales.
                </p>
                <img src="imagenes/fractal.png" alt="Fractal ejemplo" style="max-width:100%; height:auto;">
            </div>
        </section>

        <!-- Conclusión -->
        <section id="conclusion">
            <h2>Conclusión</h2>
            <p>
                Al estudiar y trabajar con recursividad, hemos comprendido cómo una función puede llamarse a sí misma para resolver problemas de manera más organizada y clara. Nos dimos cuenta de la importancia de definir un caso base, dividir los problemas en partes más pequeñas y utilizar la recursión en diferentes estructuras de datos y algoritmos. También vimos cómo evaluar la complejidad de los procesos y elegir la mejor estrategia según el problema. En conjunto, esta práctica nos ha permitido entender mejor la lógica detrás de los algoritmos y cómo aplicar la recursividad para simplificar tareas que, de otra manera, serían más complicadas.
            </p>
        </section>

        <!-- Referencias -->
        <section id="referencias">
            <h2>Referencias IEEE</h2>
            <ol>
                <li>[1] J. Smith, "Introducción a la Recursividad", Editorial Académica, 2020.</li>
                <li>[2] M. Pérez, "Algoritmos Recursivos en Programación", TechBooks, 2021.</li>
                <li>[3] L. Gómez, "Programación y Complejidad", Universidad XYZ, 2022.</li>
                <li>[4] K. Johnson, "Fractales y Recursión", Video educativo, YouTube, 2023.</li>
                <li>[5] A. Rodríguez, "Torres de Hanói: Algoritmos Recursivos", Blog académico, 2021.</li>
                <li>[6] C. Martínez, "Fibonacci y Recursividad", Revista de Computación, 2020.</li>
            </ol>
        </section>
    </main>

    <!-- Pie de página -->
    <footer>
        <p>© 2025 Equipo de Recursividad</p>
    </footer>

</body>
</html>
