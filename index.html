<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursividad en Algoritmos</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Menú de navegación -->
<nav>
    <a href="#portada">Portada</a>
    <a href="#introduccion">Introducción</a>
    <a href="#definicion">Definición</a>
    <a href="#procedimientos">Procedimientos</a>
    <a href="#caracteristicas">Características</a>
    <a href="#complejidad">Complejidad</a>
    <a href="#ejemplos">Ejemplos</a>
    <a href="#conclusion">Conclusión</a>
    <a href="#referencias">Referencias</a>
</nav>

<!-- Portada -->
<header id="portada" class="portada">
    <h1><strong>Recursividad en Algoritmos</strong></h1>
    <h2><strong>Tecnológico de Estudios Superiores de Jocotitlán</strong></h2>
    <h3><strong>División de Ingeniería en Sistemas Computacionales</strong></h3>
    <p><strong>Alumnos:</strong> Marieli Martínez, Dylan Peréz, Nau Anry Martínez</p>
    <p><strong>Docente:</strong> Doctor en C.I. Juan Alberto Antonio Velázquez</p>
    <p><strong>Materia:</strong> Estructuras de Datos</p>
</header>

<main>
    <!-- Introducción -->
    <section id="introduccion">
        <h2>Introducción</h2>
        <p>En esta página de trabajo se analiza la recursividad, un concepto clave en programación que permite a las funciones llamarse a sí mismas para resolver problemas complejos de manera elegante y estructurada.</p>
    </section>

   <!-- Definición -->
   <section id="definicion">
    <h2>Definición de Recursividad</h2>
    <p>La recursividad es una técnica de programación en la que una función o procedimiento se llama a sí misma para resolver un problema. Esta capacidad permite que problemas complejos sean descompuestos en subproblemas más simples, facilitando su resolución de manera más estructurada y elegante.</p>

    <p>La recursividad ha dejado su huella en la teoría de la computación y en el ámbito de la inteligencia artificial, siendo esencial para entender aspectos como la complejidad, la creatividad y el razonamiento. Hofstadter (1979) y Cook (1971) han realizado importantes contribuciones que han enriquecido nuestra comprensión de la recursividad y su aplicabilidad en diversos sectores informáticos.</p>

    <p>Esta habilidad permite a los desarrolladores definir una función o método que puede referirse a sí mismo para abordar un problema de una forma más efectiva y elegante. Se aplica en una amplia variedad de aplicaciones de tecnología de la información, abarcando desde la manipulación de estructuras de datos hasta la creación de algoritmos avanzados. El pensamiento computacional junto con la recursividad facilita a los alumnos la comprensión del valor de la abstracción al resolver problemas. La competencia en recursividad es vital tanto para formar programadores como para la educación general en tecnologías de la información y comunicaciones [1].</p>

    <img src="imagenes/recursividad.png" alt="Recursividad ejemplo">
</section>

<!-- Procedimientos -->
<section id="procedimientos">
    <h2>Procedimientos Recursivos</h2>
    <p>Los procedimientos recursivos utilizan la técnica de la recursión para resolver problemas. A continuación, se describen sus características y ejemplos.</p>

    <h3>Características de los Procedimientos Recursivos</h3>
    <ul>
        <li><strong>Caso Base:</strong> Es la condición que detiene la recursión. Sin un caso base, la función se llamará indefinidamente, lo que puede llevar a un desbordamiento de pila.</li>
        <li><strong>Llamada Recursiva:</strong> Es la parte de la función donde se llama a sí misma, generalmente con un argumento modificado que se aproxima al caso base.</li>
        <li><strong>División del Problema:</strong> Los procedimientos recursivos suelen dividir un problema grande en subproblemas más pequeños y manejables.</li>
    </ul>

    <h3>Ejemplo de Procedimiento Recursivo</h3>
    <p>Un ejemplo clásico de recursión es el cálculo del factorial de un número <em>n</em>:</p>

    <pre><code>
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
    </code></pre>
    
    <img src="imagenes/factorial-diagrama.png" alt="Diagrama factorial">

    <h3>Aplicaciones de la Recursividad</h3>
    <p>Algunas aplicaciones comunes de la recursividad:</p>
    <ul>
        <li><strong>Búsqueda y Ordenación:</strong> Binaria, Quicksort.</li>
        <li><strong>Problemas Matemáticos:</strong> Fibonacci, Torres de Hanoi.</li>
        <li><strong>Estructuras de Datos:</strong> Árboles, Listas enlazadas.</li>
        <li><strong>Programación Dinámica:</strong> Algoritmos que almacenan subresultados (memorization).</li>
    </ul>

    <img src="imagenes/fibonacci-diagrama.png" alt="Diagrama Fibonacci">
</section>

<!-- Características -->
<section id="caracteristicas">
    <h2>Características de la Recursividad</h2>
    <ol>
        <li><strong>Caso Base:</strong> Detiene la recursión. Ejemplo: factorial(0) = 1.</li>
        <li><strong>Llamada Recursiva:</strong> La función se llama a sí misma. Ejemplo: Fibonacci(n-1, n-2).</li>
        <li><strong>División del Problema:</strong> Simplifica el problema en subproblemas.</li>
        <li><strong>Estructura de Datos:</strong> Árboles y grafos se manejan muy bien con recursión.</li>
        <li><strong>Memorization:</strong> Almacena resultados de subproblemas para optimización.</li>
        <li><strong>Complejidad Temporal y Espacial:</strong> La recursión puede requerir más memoria y tiempo.</li>
    </ol>

    <h3>Ejemplo Visual</h3>
    <pre><code>
factorial(3)
 └── 3 * factorial(2)
      └── 2 * factorial(1)
           └── 1 * factorial(0)
                └── 1 (caso base)
    </code></pre>
</section>

<!-- Complejidad -->
<section id="complejidad">
    <h2>Complejidad Computacional</h2>
    <p>La complejidad computacional analiza recursos como tiempo y memoria. Se representa con Big O.</p>

    <h3>Notación Big O Común</h3>
    <ul>
        <li>O(1), O(n), O(n log n), O(n²)</li>
    </ul>

    <img src="imagenes/big-o.png" alt="Gráfica Big O">

    <h3>Ejemplo: Factorial Recursivo</h3>
    <pre><code>
public class Factorial {
    public static int factorial(int n) {
        return (n == 0) ? 1 : n * factorial(n - 1);
    }
}
    </code></pre>
</section>

<!-- Ejemplos -->
<section id="ejemplos">
    <h2>Ejemplos de Algoritmos Recursivos</h2>

    <div class="algoritmo">
        <h3>Torres de Hanói</h3>
        <p>Mover n discos de un poste a otro siguiendo reglas específicas.</p>
        <img src="imagenes/torres-hanoi.png" alt="Torres de Hanoi">
    </div>

    <div class="algoritmo">
        <h3>Fractales</h3>
        <p>Figuras geométricas auto-similares. Ejemplo: Triángulo de Sierpinski.</p>
        <img src="imagenes/fractal.png" alt="Fractal ejemplo">
    </div>
</section>

<!-- Conclusión -->
<section id="conclusion">
    <h2>Conclusión</h2>
    <p>
        Hemos comprendido cómo una función puede llamarse a sí misma para resolver problemas de manera organizada. Vimos la importancia de un caso base, la división de problemas y la recursión en estructuras de datos y algoritmos.
    </p>
    <img src="imagenes/recursion-conclusion.png" alt="Conclusión recursión">
</section>

<!-- Referencias -->
<section id="referencias">
    <h2>Referencias IEEE</h2>
    <ol>
        <li>[1] J. Smith, "Introducción a la Recursividad", Editorial Académica, 2020.</li>
        <li>[2] M. Pérez, "Algoritmos Recursivos en Programación", TechBooks, 2021.</li>
        <li>[3] L. Gómez, "Programación y Complejidad", Universidad XYZ, 2022.</li>
        <li>[4] K. Johnson, "Fractales y Recursión", Video educativo, YouTube, 2023.</li>
        <li>[5] A. Rodríguez, "Torres de Hanói: Algoritmos Recursivos", Blog académico, 2021.</li>
        <li>[6] C. Martínez, "Fibonacci y Recursividad", Revista de Computación, 2020.</li>
    </ol>
</section>
</main>

<!-- Pie de página -->
<footer>
    <p>© 2025 Equipo de Recursividad</p>
</footer>

</body>
</html>
